import asyncio
import websockets
import json
import time
import os
import subprocess

COMMANDS = {
    "horas": {"description": "Verificar o hor√°rio", "os_command": "date +%H:%M"},
    "data": {"description": "Verificar a data", "os_command": "date +%d/%m/%Y"},
    "tempo": {"description": "Verificar o clima", "os_command": "curl wttr.in?format=3"}
}

async def send_to_tts(response):
    """Fun√ß√£o para enviar resposta ao servidor TTS via WebSocket"""
    while True:
        try:
            async with websockets.connect("ws://localhost:8766") as tts_ws:
                await tts_ws.send(json.dumps({"response": response}))
            break
        except websockets.exceptions.ConnectionClosedError:
            print("‚ö†Ô∏è Erro: Conex√£o com o servidor TTS foi fechada inesperadamente. Tentando reconectar...")
            await asyncio.sleep(2)
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao conectar ao servidor TTS: {e}. Tentando novamente em 2 segundos.")
            await asyncio.sleep(2)

def score_command(input_command, commands):
    """Calcula um score de similaridade para o comando de entrada contra os comandos conhecidos."""
    import difflib
    scores = {}
    for command in commands:
        score = difflib.SequenceMatcher(None, input_command, command).ratio() * 100
        scores[command] = score
    matched_command = max(scores, key=scores.get)
    return scores[matched_command], matched_command

async def process_command(websocket, path):
    """Processa os comandos recebidos via WebSocket"""
    try:
        async for message in websocket:
            data = json.loads(message)
            command = data.get("command", "").lower()
            score, matched_command = score_command(command, COMMANDS.keys())
            
            if score > 90:
                task = COMMANDS[matched_command]
                print(f"üõ†Ô∏è Comando detectado: {task['description']}")
                
                command_detected_message = f"Comando detectado: {task['description']}"
                print(command_detected_message)
                
                os_command = task["os_command"]
                try:
                    result = subprocess.run(os_command, shell=True, capture_output=True, text=True)
                    if result.returncode == 0:
                        response = result.stdout.strip()
                    else:
                        response = f"Erro ao executar o comando: {result.stderr.strip()}"
                except Exception as e:
                    response = f"Erro ao executar o comando: {str(e)}"
            
            elif 60 < score <= 90:
                task = COMMANDS[matched_command]
                print(f"üõ†Ô∏è Comando detectado: {task['description']}")
                
                confirmation_message = f"Voc√™ quis dizer '{matched_command}'?"
                await send_to_tts(confirmation_message)
                
                # Aqui voc√™ precisaria de uma fun√ß√£o para reconhecimento de voz, mas como n√£o pode executar c√≥digo, assumimos que h√° uma fun√ß√£o 'receive_confirmation'
                confirmation = await receive_confirmation(websocket)  # Placeholder para receber confirma√ß√£o
                if confirmation == "sim":
                    os_command = task["os_command"]
                    try:
                        result = subprocess.run(os_command, shell=True, capture_output=True, text=True)
                        if result.returncode == 0:
                            response = result.stdout.strip()
                        else:
                            response = f"Erro ao executar o comando: {result.stderr.strip()}"
                    except Exception as e:
                        response = f"Erro ao executar o comando: {str(e)}"
                else:
                    response = "Comando cancelado."
            else:
                response = "Desculpe, n√£o entendi o comando."

            print(f"‚úÖ Comando recebido: {command} -> {response}")
            await send_to_tts(response)
    except websockets.exceptions.ConnectionClosedError:
        print("‚ö†Ô∏è Erro: Conex√£o com o WebSocket foi fechada inesperadamente. Tentando reconectar...")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao processar o comando: {e}")
        await asyncio.sleep(2)

async def main():
    """Inicia o servidor WebSocket"""
    while True:
        try:
            async with websockets.serve(process_command, "localhost", 8765):
                print("üß† Servidor WebSocket iniciado na porta 8765")
                await asyncio.Future()  # Mant√©m o servidor rodando
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao iniciar o servidor WebSocket: {e}. Tentando reiniciar em 5 segundos.")
            await asyncio.sleep(5)

# Inicia o servidor WebSocket
asyncio.run(main())
